/*
		MCheck main program

*/
#include "globals.h"

#define SKIP_EXCEPT (DEBUG && 0)

#define PRG cout << __FILE__ << ":" << __LINE__ << "\n";

// read DFA from internal table, to avoid having to
// load an external .bin file
extern unsigned char _dfa[];

int main(int argc, char** argv) {

	bool error = false;

	// -b
	bool showBuchi = false;

	// -r
	bool printReduced = false;

	// -v
	bool verbose = false;

	// -m
	bool showMarkedCTL = false;

	// true if we're to read from stdIn
	bool stdIn = true;
	InputStreamWrapper cinReader(std::cin);

	// true if formulas have been entered
	bool formulasDefined = false;

	// symbol table for prop. variables
	Vars vars;

	// tokenizer
	DFA dfa;
	
	{
		// initialize DFA, either from external file, or internal table
#if DOS && DEBUG && 0
		BinaryReader rd("tokens.dfa");
		dfa.read(rd);

		ByteBufferWriter br;
		dfa.write(br);
		TextWriter w("_dfa_.txt");
		pr(("Writing dfa to %s in %s,%d\n",
			w.path().chars(),__FILE__,__LINE__ ));
		br.dumpCPP(w);
#else
		ByteBufferReader rd(_dfa);
		dfa.read(rd);
#endif
	}

	Scanner scan(0,&dfa);
	scan.setSkip(TK_WS);
	Model model(vars);
	
	// the formulas rely on the forest and tokens, so
	// construct them first...

	Forest forest;	
	SArray<Token> tokens;

	Formula::setAuxDataStructures(forest,tokens);

	static const char *title =
			"--//  mch: Kripke Model Checker for LTL & CTL Formulas\n"
			"-//        Written by Jeff Sember, Spring 2005\n"
			"\n";

	{
		CmdArgs args(argc,argv);
		try {
		
#if DEBUG
			if (!args.hasNext()) {
				args.addArguments(
//					"-b " // print Buchi automata for LTL operations
//					"-e "	// echo input files as they are read
//					"-m " // show CTL formulas as marked in states
//					"-r " // show formulas after reduction to minimal adequate sets
//					"-v " // verbose operation
						"test/script.txt "
					""
				);
			}
#endif

			// command line options:

			while (true) {
				if (args.nextIsValue()) {
					stdIn = false;
					scan.queueTextFile(args.nextValue());
					//sourceFiles.add(args.nextValue());
					continue;
				}
				if (args.peekOption('h')) {
					throw CmdArgException("");
				}

#if DEBUG
				if (args.peekOption('t')) {
					continue;
				}
#endif
				if (args.peekOption('b')) {
					showBuchi = true;
					continue;
				}
				if (args.peekOption('e')) {
					scan.setEcho(true);
					continue;
				}
				if (args.peekOption('v')) {
					verbose = true;
					continue;
				}
				if (args.peekOption('m')) {
					showMarkedCTL = true;
					continue;
				}
				if (args.peekOption('r')) {
					printReduced = true;
					continue;
				}
				if (args.peekOption('p')) {
					Formula::filterParen(false);
					continue;
				}
				break;
			}

			args.done();

			if (stdIn) {
				scan.includeSource(cinReader);
			}

			LTLCheck c(vars, 
					(verbose ? LTLCheck::OPT_PRINTSTATES : 0)
				| (verbose ? LTLCheck::OPT_PRINTFULLSEQ : 0)
				| (showBuchi ? LTLCheck::OPT_PRINTBUCHI : 0)
			);

#if SKIP_EXCEPT
			WARN("Not catching exceptions");
#else
			try 
#endif
			{
				while (!scan.eof()) {
					Token t;
					scan.peek(t);
					//	is it a model definition?
					if (t.type(TK_MODELOP)) {
						model.clear(); 
						vars.clear();
						formulasDefined = false;
						model.parse(scan);

						Cout << "Parsed model, " << model.states() << " states\n\n";
						if (verbose) {
							model.print();
							Cout << "\n";
							formulasDefined = true;
						}

					} else if (t.type(TK_COMPARE)) {

						// ? <form> : <form>
						// compare two LTL formulas

						formulasDefined = model.defined();
						scan.read();

						Formula f1;
						f1.parse(scan);

						scan.read(TK_COMPAREMID);

						Formula f2;
						f2.parse(scan);

						c.compare(f1,f2,printReduced);
					} else {

						// assume it's a formula.

						formulasDefined = model.defined();

						Formula f;
						f.parse(scan);
						f.print();
						if (printReduced) {
							Utils::pad(6);
							f.printReduced();
						}
						Cout << "\n";

						if (!model.defined()) 
							continue;

						// if a model has been defined, 
						// check it against this formula.

						if (f.isCTL()
		#if FAVOR_LTL
								// treat as LTL if both for debug purposes
							&& !f.isLTL()
		#endif
						) {
							CTLCheck c;
							BitStore sat;
							c.check(vars,model, f, &sat, verbose, showMarkedCTL);

							String s;
//							int count = 0;

							// Verify that all start states satisfy the formula
							const OrdSet &is = model.initialStates();
							bool first = true;
							for (int i = 0; i < is.length(); i++) {
								int iName = is[i];
								if (!sat.get(model.stateId(iName))) {
									if (first) {
										s << "Not satisfied; start states: ";
										first = false;
									} else
										s << ' ';
									s << iName;
								}
							}
							if (first)
								s << "Satisfied.";
							s << "\n";

							s << "\n";
							Cout << s;
							continue;
						}

						if (f.isLTL()) {
							c.check(model, f);
							continue;
						}

						Cout << "(cannot check mixed CTL/LTL formula...)\n\n";
						continue;
					}
				}

				if (!formulasDefined && model.defined()) {
					model.print();
					Cout << "\n";
				}
			} 
#if SKIP_EXCEPT
			try {
			}
#endif
			catch (Exception &e) {
				scan.addError(e.str());
				scan.flushErrors();
			} 
		} catch (CmdArgException &e) {
      Cout << e 
				<< title
        << "Usage: mch <opts> {<input file>}*\n"
        << "  <input file>  : text file to read models, specifications from;\n"
        << "                      if none specified, uses standard input\n"
        << "<opts> include:\n"
        << " -e             : echo input files\n"
        << " -h             : print help\n"
        << " -m             : show formulas as they're marked in states (CTL only)\n"
        << " -p             : don't filter out unnecessary parentheses\n"
        << " -r             : display reduced formulas\n"
        << " -v             : verbose output\n"
				;
		} catch (Exception &e) {
 			Utils::useSink(&Utils::getErrorSink());
			Cout << e;
		}
	}
	return error ? 1 : 0;
}

/*	Binary data for DFA.  This is to avoid requiring auxilliary
		data files (xxx.dfa) with the distribution.
*/
unsigned char _dfa[] = {
	0x92,0x99,0x00,0x00,0x25,0x00,0x00,0x00,0x1F,0x00,0x00,0x00,0x00,0x00,0x5D,0x00,
	0x01,0x01,0x02,0x01,0x03,0x01,0x04,0x01,0x05,0x01,0x06,0x01,0x07,0x01,0x08,0x01,
	0x09,0x01,0x0A,0x01,0x0B,0x01,0x0C,0x01,0x0D,0x01,0x0E,0x01,0x0F,0x01,0x10,0x01,
	0x11,0x01,0x12,0x01,0x13,0x01,0x14,0x01,0x15,0x01,0x16,0x01,0x17,0x01,0x18,0x01,
	0x19,0x01,0x1A,0x01,0x1B,0x01,0x1C,0x01,0x1D,0x01,0x1E,0x01,0x1F,0x01,0x20,0x01,
	0x21,0x02,0x25,0x03,0x26,0x04,0x28,0x05,0x29,0x06,0x2D,0x23,0x2F,0x22,0x30,0x07,
	0x31,0x07,0x32,0x07,0x33,0x07,0x34,0x07,0x35,0x07,0x36,0x07,0x37,0x07,0x38,0x07,
	0x39,0x07,0x3A,0x08,0x3E,0x09,0x3F,0x0A,0x41,0x21,0x42,0x0B,0x45,0x24,0x46,0x0C,
	0x47,0x0D,0x52,0x0E,0x54,0x0F,0x55,0x10,0x57,0x11,0x58,0x12,0x5D,0x13,0x5F,0x14,
	0x61,0x14,0x62,0x14,0x63,0x14,0x64,0x14,0x65,0x14,0x66,0x14,0x67,0x14,0x68,0x14,
	0x69,0x14,0x6A,0x14,0x6B,0x14,0x6C,0x14,0x6D,0x14,0x6E,0x14,0x6F,0x14,0x70,0x14,
	0x71,0x14,0x72,0x14,0x73,0x14,0x74,0x14,0x75,0x14,0x76,0x14,0x77,0x14,0x78,0x14,
	0x79,0x14,0x7A,0x14,0x7B,0x15,0x7C,0x16,0x7D,0x17,0x01,0x00,0x00,0x80,0x20,0x00,
	0x01,0x01,0x02,0x01,0x03,0x01,0x04,0x01,0x05,0x01,0x06,0x01,0x07,0x01,0x08,0x01,
	0x09,0x01,0x0A,0x01,0x0B,0x01,0x0C,0x01,0x0D,0x01,0x0E,0x01,0x0F,0x01,0x10,0x01,
	0x11,0x01,0x12,0x01,0x13,0x01,0x14,0x01,0x15,0x01,0x16,0x01,0x17,0x01,0x18,0x01,
	0x19,0x01,0x1A,0x01,0x1B,0x01,0x1C,0x01,0x1D,0x01,0x1E,0x01,0x1F,0x01,0x20,0x01,
	0x08,0x00,0x00,0x80,0x00,0x00,0x01,0x00,0x00,0x80,0x7E,0x00,0x01,0x03,0x02,0x03,
	0x03,0x03,0x04,0x03,0x05,0x03,0x06,0x03,0x07,0x03,0x08,0x03,0x09,0x03,0x0B,0x03,
	0x0C,0x03,0x0D,0x03,0x0E,0x03,0x0F,0x03,0x10,0x03,0x11,0x03,0x12,0x03,0x13,0x03,
	0x14,0x03,0x15,0x03,0x16,0x03,0x17,0x03,0x18,0x03,0x19,0x03,0x1A,0x03,0x1B,0x03,
	0x1C,0x03,0x1D,0x03,0x1E,0x03,0x1F,0x03,0x20,0x03,0x21,0x03,0x22,0x03,0x23,0x03,
	0x24,0x03,0x25,0x03,0x26,0x03,0x27,0x03,0x28,0x03,0x29,0x03,0x2A,0x03,0x2B,0x03,
	0x2C,0x03,0x2D,0x03,0x2E,0x03,0x2F,0x03,0x30,0x03,0x31,0x03,0x32,0x03,0x33,0x03,
	0x34,0x03,0x35,0x03,0x36,0x03,0x37,0x03,0x38,0x03,0x39,0x03,0x3A,0x03,0x3B,0x03,
	0x3C,0x03,0x3D,0x03,0x3E,0x03,0x3F,0x03,0x40,0x03,0x41,0x03,0x42,0x03,0x43,0x03,
	0x44,0x03,0x45,0x03,0x46,0x03,0x47,0x03,0x48,0x03,0x49,0x03,0x4A,0x03,0x4B,0x03,
	0x4C,0x03,0x4D,0x03,0x4E,0x03,0x4F,0x03,0x50,0x03,0x51,0x03,0x52,0x03,0x53,0x03,
	0x54,0x03,0x55,0x03,0x56,0x03,0x57,0x03,0x58,0x03,0x59,0x03,0x5A,0x03,0x5B,0x03,
	0x5C,0x03,0x5D,0x03,0x5E,0x03,0x5F,0x03,0x60,0x03,0x61,0x03,0x62,0x03,0x63,0x03,
	0x64,0x03,0x65,0x03,0x66,0x03,0x67,0x03,0x68,0x03,0x69,0x03,0x6A,0x03,0x6B,0x03,
	0x6C,0x03,0x6D,0x03,0x6E,0x03,0x6F,0x03,0x70,0x03,0x71,0x03,0x72,0x03,0x73,0x03,
	0x74,0x03,0x75,0x03,0x76,0x03,0x77,0x03,0x78,0x03,0x79,0x03,0x7A,0x03,0x7B,0x03,
	0x7C,0x03,0x7D,0x03,0x7E,0x03,0x7F,0x03,0x09,0x00,0x00,0x80,0x00,0x00,0x10,0x00,
	0x00,0x80,0x00,0x00,0x11,0x00,0x00,0x80,0x00,0x00,0x0C,0x00,0x00,0x80,0x0A,0x00,
	0x30,0x07,0x31,0x07,0x32,0x07,0x33,0x07,0x34,0x07,0x35,0x07,0x36,0x07,0x37,0x07,
	0x38,0x07,0x39,0x07,0x06,0x00,0x00,0x80,0x00,0x00,0x04,0x00,0x00,0x80,0x00,0x00,
	0x05,0x00,0x00,0x80,0x00,0x00,0x16,0x00,0x00,0x80,0x00,0x00,0x18,0x00,0x00,0x80,
	0x00,0x00,0x19,0x00,0x00,0x80,0x00,0x00,0x13,0x00,0x00,0x80,0x00,0x00,0x15,0x00,
	0x00,0x80,0x00,0x00,0x12,0x00,0x00,0x80,0x00,0x00,0x14,0x00,0x00,0x80,0x00,0x00,
	0x17,0x00,0x00,0x80,0x00,0x00,0x0F,0x00,0x00,0x80,0x00,0x00,0x0B,0x00,0x00,0x80,
	0x3F,0x00,0x30,0x14,0x31,0x14,0x32,0x14,0x33,0x14,0x34,0x14,0x35,0x14,0x36,0x14,
	0x37,0x14,0x38,0x14,0x39,0x14,0x41,0x14,0x42,0x14,0x43,0x14,0x44,0x14,0x45,0x14,
	0x46,0x14,0x47,0x14,0x48,0x14,0x49,0x14,0x4A,0x14,0x4B,0x14,0x4C,0x14,0x4D,0x14,
	0x4E,0x14,0x4F,0x14,0x50,0x14,0x51,0x14,0x52,0x14,0x53,0x14,0x54,0x14,0x55,0x14,
	0x56,0x14,0x57,0x14,0x58,0x14,0x59,0x14,0x5A,0x14,0x5F,0x14,0x61,0x14,0x62,0x14,
	0x63,0x14,0x64,0x14,0x65,0x14,0x66,0x14,0x67,0x14,0x68,0x14,0x69,0x14,0x6A,0x14,
	0x6B,0x14,0x6C,0x14,0x6D,0x14,0x6E,0x14,0x6F,0x14,0x70,0x14,0x71,0x14,0x72,0x14,
	0x73,0x14,0x74,0x14,0x75,0x14,0x76,0x14,0x77,0x14,0x78,0x14,0x79,0x14,0x7A,0x14,
	0x02,0x00,0x00,0x80,0x00,0x00,0x0A,0x00,0x00,0x80,0x00,0x00,0x03,0x00,0x00,0x80,
	0x00,0x00,0x07,0x00,0x00,0x80,0x00,0x00,0x1C,0x00,0x00,0x80,0x00,0x00,0x1A,0x00,
	0x00,0x80,0x00,0x00,0x1E,0x00,0x00,0x80,0x00,0x00,0x0D,0x00,0x00,0x80,0x00,0x00,
	0x1D,0x00,0x00,0x80,0x00,0x00,0x1B,0x00,0x00,0x80,0x00,0x00,0x1F,0x00,0x00,0x80,
	0x00,0x00,0x0E,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x46,0x19,
	0x47,0x1A,0x58,0x1B,0x5B,0x1C,0x00,0x00,0x00,0x00,0x01,0x00,0x2F,0x03,0x00,0x00,
	0x00,0x00,0x02,0x00,0x2D,0x03,0x3E,0x18,0x00,0x00,0x00,0x00,0x04,0x00,0x46,0x1D,
	0x47,0x1E,0x58,0x1F,0x5B,0x20,0x57,0x48,0x49,0x54,0x45,0x53,0x50,0x41,0x43,0x45,
	0x00,0x4D,0x4F,0x44,0x45,0x4C,0x4F,0x50,0x00,0x4D,0x4F,0x44,0x45,0x4C,0x43,0x4C,
	0x00,0x49,0x4E,0x49,0x54,0x49,0x41,0x4C,0x53,0x54,0x41,0x54,0x45,0x00,0x43,0x4F,
	0x4D,0x50,0x41,0x52,0x45,0x00,0x43,0x4F,0x4D,0x50,0x41,0x52,0x45,0x4D,0x49,0x44,
	0x00,0x49,0x4D,0x50,0x4C,0x49,0x45,0x53,0x00,0x4E,0x45,0x47,0x41,0x54,0x49,0x4F,
	0x4E,0x00,0x41,0x4E,0x44,0x00,0x4F,0x52,0x00,0x50,0x52,0x4F,0x50,0x56,0x41,0x52,
	0x00,0x49,0x4E,0x54,0x56,0x41,0x4C,0x00,0x41,0x4C,0x4C,0x5F,0x55,0x4E,0x54,0x49,
	0x4C,0x00,0x45,0x58,0x49,0x53,0x54,0x53,0x5F,0x55,0x4E,0x54,0x49,0x4C,0x00,0x41,
	0x45,0x5F,0x55,0x4E,0x54,0x49,0x4C,0x5F,0x45,0x4E,0x44,0x00,0x50,0x41,0x52,0x4F,
	0x50,0x00,0x50,0x41,0x52,0x43,0x4C,0x00,0x55,0x4E,0x54,0x49,0x4C,0x00,0x52,0x45,
	0x4C,0x45,0x41,0x53,0x45,0x00,0x57,0x45,0x41,0x4B,0x55,0x4E,0x54,0x49,0x4C,0x00,
	0x54,0x52,0x55,0x45,0x00,0x42,0x4F,0x54,0x54,0x4F,0x4D,0x00,0x4E,0x45,0x58,0x54,
	0x00,0x46,0x55,0x54,0x55,0x52,0x45,0x00,0x47,0x4C,0x4F,0x42,0x41,0x4C,0x00,0x41,
	0x47,0x00,0x45,0x47,0x00,0x41,0x46,0x00,0x45,0x46,0x00,0x41,0x58,0x00,0x45,0x58,
	0x00
};
